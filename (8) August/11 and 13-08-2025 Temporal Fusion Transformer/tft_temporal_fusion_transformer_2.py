# -*- coding: utf-8 -*-
"""TFT Temporal Fusion Transformer 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11D5kU3ZtVB4y26JPYXyMBUCcY_uNmwo3

# **Second Code**

✅ Cell 1: Install Dependencies
"""

# Install specific versions
!pip install pytorch-lightning==2.4.0 pytorch-forecasting==1.4.0 --quiet

"""✅ Cell 2: Load and Prepare the Data"""

import pandas as pd
import numpy as np
import torch
from sklearn.metrics import mean_squared_error, mean_absolute_error
import matplotlib.pyplot as plt

# Load dataset
df = pd.read_csv("/content/sample_data/dengue data 17-07-2025.csv")  # Change path if needed

# Convert date column
df['week_start_date'] = pd.to_datetime(df['week_start_date'])

# Filter only 'sj' city
df = df[df['city'] == 'sj'].copy()

# Fill missing values
df.fillna(method='ffill', inplace=True)
df.fillna(method='bfill', inplace=True)

# Extract date features
df['month'] = df['week_start_date'].dt.month
df['day'] = df['week_start_date'].dt.day
df['dayofweek'] = df['week_start_date'].dt.dayofweek
df['year'] = df['week_start_date'].dt.year

# Convert city to categorical code
df['city'] = df['city'].astype('category').cat.codes

# Sort and create continuous time index
df = df.sort_values('week_start_date').reset_index(drop=True)
df['time_idx'] = df.index

import matplotlib.pyplot as plt

# Plot total_cases over time before outlier removal
plt.figure(figsize=(14, 6))
plt.plot(df['week_start_date'], df['total_cases'], label='Before Outlier Removal', color='orange')

# Define IQR bounds
Q1 = df["total_cases"].quantile(0.25)
Q3 = df["total_cases"].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Remove outliers
df_cleaned = df[(df["total_cases"] >= lower_bound) & (df["total_cases"] <= upper_bound)]

# Plot total_cases over time after outlier removal
plt.plot(df_cleaned['week_start_date'], df_cleaned['total_cases'], label='After Outlier Removal', color='blue')

plt.xlabel('Date')
plt.ylabel('Total Cases')
plt.title('Total Cases Over Time Before and After Outlier Removal')
plt.legend()
plt.grid(True)
plt.show()

# Update df to cleaned data and reset time_idx
df = df_cleaned.sort_values("week_start_date").reset_index(drop=True)
df["time_idx"] = df.index

df.info()

"""✅ Cell 3: Train/Test Split"""

# 80/20 split
train_size = int(len(df) * 0.8)
train_df = df.iloc[:train_size].copy()
test_df = df.iloc[train_size:].copy()
train_df["time_idx"]

"""✅ Cell 4: Prepare TimeSeriesDataSet"""

from pytorch_forecasting import TimeSeriesDataSet
from pytorch_forecasting.data.encoders import GroupNormalizer
from pytorch_lightning import seed_everything

seed_everything(42)

# Define features
features = [
    'city', 'year', 'ndvi_ne', 'ndvi_nw', 'ndvi_se', 'ndvi_sw',
    'precipitation_amt_mm', 'reanalysis_air_temp_k', 'reanalysis_tdtr_k',
    'station_avg_temp_c', 'station_diur_temp_rng_c', 'station_max_temp_c',
    'station_min_temp_c', 'station_precip_mm', 'month', 'day', 'dayofweek'
]

target = 'total_cases'
max_encoder_length = 30
max_prediction_length = 10
training_cutoff = train_df["time_idx"].max() - max_prediction_length

# Create training dataset
training = TimeSeriesDataSet(
    train_df,#[lambda x: x.time_idx <= training_cutoff],
    time_idx="time_idx",
    target=target,
    group_ids=["city"],
    min_encoder_length=max_encoder_length // 2,
    max_encoder_length=max_encoder_length,
    max_prediction_length=max_prediction_length,
    time_varying_known_reals=["time_idx"] + features,
    time_varying_unknown_reals=[target],
    target_normalizer=GroupNormalizer(groups=["city"]),
    allow_missing_timesteps=True
)

validation = TimeSeriesDataSet.from_dataset(training, test_df, stop_randomization=True)

"""✅ Cell 5: Create DataLoaders"""

batch_size = 64
train_dataloader = training.to_dataloader(train=True, batch_size=batch_size, num_workers=0)
val_dataloader = validation.to_dataloader(train=False, batch_size=batch_size, num_workers=0)

"""
✅ Cell 6: Define and Train TFT Model"""

# ✅ Cell 6: Define and Train TFT Model (consistent Lightning imports)

import lightning.pytorch as L
from lightning.pytorch.callbacks import EarlyStopping, LearningRateMonitor
from pytorch_forecasting import TemporalFusionTransformer
from pytorch_forecasting.metrics import QuantileLoss
import torch

# (optional) a tiny perf tweak on CPU
torch.set_float32_matmul_precision("medium")

early_stop = EarlyStopping(monitor="val_loss", patience=5, mode="min")
lr_logger = LearningRateMonitor(logging_interval="epoch")

trainer = L.Trainer(
    max_epochs=30,
    gradient_clip_val=0.1,
    callbacks=[early_stop, lr_logger],
    accelerator="auto",   # will use CPU here (GPU not available)
    devices=1,
)

# Build TFT from the *training dataset*, not the dataloader
tft = TemporalFusionTransformer.from_dataset(
    training,
    learning_rate=0.005,
    hidden_size=64,
    attention_head_size=4,
    dropout=0.1,
    hidden_continuous_size=64,
    output_size=7,               # 7 quantiles
    loss=QuantileLoss(),         # required when using quantiles
    log_interval=10,
    reduce_on_plateau_patience=5
)

# Sanity check: should print True
print("Is LightningModule?", isinstance(tft, L.LightningModule))

trainer.fit(
    model=tft,
    train_dataloaders=train_dataloader,
    val_dataloaders=val_dataloader,
)

"""✅ Cell 7: Evaluate the Model"""

best_model_path = trainer.checkpoint_callback.best_model_path
best_model = TemporalFusionTransformer.load_from_checkpoint(best_model_path)

actuals = torch.cat([y[0] for x, y in iter(val_dataloader)])
predictions = best_model.predict(val_dataloader)

y_true = actuals.numpy()
y_pred = predictions.numpy()

mse = mean_squared_error(y_true, y_pred)
rmse = np.sqrt(mse)
mae = mean_absolute_error(y_true, y_pred)

print(f"MSE: {mse:.2f}")
print(f"RMSE: {rmse:.2f}")
print(f"MAE: {mae:.2f}")

"""✅ Cell 8: Plot Actual vs Predicted"""

plt.figure(figsize=(15, 6))
plt.plot(y_true, label='Actual')
plt.plot(y_pred, label='Forecasted', linestyle='--')
plt.title("Actual vs Forecasted Total Cases (City: SJ)")
plt.xlabel("Time Step")
plt.ylabel("Total Cases")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Suppose predictions.shape = (n_samples, prediction_length)
median_forecast = np.median(predictions, axis=0)  # median over samples

plt.figure(figsize=(15,5))
plt.plot(actuals, label="Actual", color="black")
plt.plot(predictions, label="Forecasted", linestyle="--", color="red")
plt.legend()
plt.title("Actual vs Forecasted Total Cases")
plt.xlabel("Time Step")
plt.ylabel("Total Cases")
plt.show()

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Assume:
# df has columns ['time_idx', 'total_cases']
# test_df is the held-out period
# predictions is TFT predictions aligned with test_df time_idx

# Make a copy of test_df with forecast column
forecast_df = test_df.copy()

# Ensure predictions are aligned with test_df time_idx
# Since predictions is a numpy array, we need to ensure its length matches test_df
if len(predictions) != len(test_df):
    # This is a simplified assumption: if the lengths don't match,
    # we'll just take the first len(test_df) predictions.
    # A more robust solution might involve matching time indices if they were available in predictions.
    print(f"Warning: Length of predictions ({len(predictions)}) does not match test_df ({len(test_df)}). Truncating predictions.")
    predictions = predictions[:len(test_df)]

# Select the median prediction for each time step
median_predictions = np.median(predictions, axis=1)

forecast_df["forecast"] = median_predictions  # predictions must match test_df length

plt.figure(figsize=(15,5))

# 1. Full actual data
plt.plot(actuals, label="Actual (Train+Test)", color="black", alpha=0.5)

# 2. Actual test data (highlighted)
plt.plot(test_df["total_cases"], label="Actual (Test)", color="blue")

# 3. Forecasted test data
plt.plot(predictions, label="Forecasted", color="red", linestyle="--")

plt.title("Actual vs Test vs Forecasted Total Cases")
plt.xlabel("Time Step")
plt.ylabel("Total Cases")
plt.legend()
plt.show()

# Get predictions, input, and actuals
y_pred, x, y_true = best_model.predict(val_dataloader, return_x=True, return_y=True)

# Convert to numpy
y_pred = y_pred.flatten().detach().cpu().numpy()
y_true = y_true.flatten().detach().cpu().numpy()

# Plot
import matplotlib.pyplot as plt

plt.figure(figsize=(18, 6))
plt.plot(y_true, label="Actual", color="black")
plt.plot(y_pred, label="Forecasted", linestyle='--', color="red")
plt.title("Actual vs Forecasted Total Cases (City: SJ)")
plt.xlabel("Time Step")
plt.ylabel("Total Cases")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Request prediction and actuals
predictions = best_model.predict(val_dataloader, return_x=True, return_y=True)

# Confirm what was returned
print(type(predictions))
print(dir(predictions))

# Perform prediction
predictions = best_model.predict(val_dataloader, return_x=True, return_y=True)

# Extract forecasted predictions and actual future values
y_pred = predictions.output.flatten().detach().cpu().numpy()
y_true = predictions.y.flatten().detach().cpu().numpy()

# Plotting
import matplotlib.pyplot as plt

plt.figure(figsize=(18, 6))
plt.plot(y_true, label="Actual", color="black")
plt.plot(y_pred, label="Forecasted", linestyle='--', color="red")
plt.title("Actual vs Forecasted Total Cases (City: SJ)")
plt.xlabel("Time Step")
plt.ylabel("Total Cases")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Perform prediction
predictions = best_model.predict(val_dataloader, return_x=True, return_y=True)

# ✅ Extract forecasted predictions
y_pred = predictions.output.flatten().detach().cpu().numpy()

# ✅ Extract actual values (first element of the tuple)
y_true_tensor = predictions.y[0]  # predictions.y is a tuple: (actuals, weightings)
y_true = y_true_tensor.flatten().detach().cpu().numpy()

# Plotting
import matplotlib.pyplot as plt

plt.figure(figsize=(18, 6))
plt.plot(y_true, label="Actual", color="black")
plt.plot(y_pred, label="Forecasted", linestyle='-', color="red")
plt.title("Actual vs Forecasted Total Cases (City: SJ)")
plt.xlabel("Time Step")
plt.ylabel("Total Cases")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Get training targets (true total_cases from train_df)
train_targets = train_df["total_cases"].values

# Trim to match forecast length
# In case prediction length is shorter than test set due to batching
forecast_length = len(y_pred)
test_targets = test_df["total_cases"].values[:forecast_length]

# Build full sequences
full_timeline = np.arange(len(train_targets) + forecast_length)
train_line = np.concatenate([train_targets, [np.nan]*forecast_length])
actual_line = np.concatenate([[np.nan]*len(train_targets), test_targets])
forecast_line = np.concatenate([[np.nan]*len(train_targets), y_pred])

# Plot all 3 lines
plt.figure(figsize=(18, 6))
plt.plot(full_timeline, train_line, label="Training Data", color="green")
plt.plot(full_timeline, actual_line, label="Actual Data", color="red")
plt.plot(full_timeline, forecast_line, label="Forecasted Data", color="blue", linestyle='--')

# Style
plt.title("Dengue Cases Forecast - City: SJ")
plt.xlabel("Time Step (Weeks)")
plt.ylabel("Total Cases")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Get training total cases
train_targets = train_df["total_cases"].values

# Get validation targets (trimmed to forecast length)
forecast_length = len(y_pred)
test_targets = test_df["total_cases"].values[:forecast_length]

# Trim in case actuals are longer than forecast
y_true_trimmed = y_true[:forecast_length]
y_pred_trimmed = y_pred[:forecast_length]

# Build timeline for full plot
full_length = len(train_targets) + forecast_length
full_timeline = np.arange(full_length)

# Build plot lines with NaNs in non-relevant areas
train_line = np.concatenate([train_targets, [np.nan]*forecast_length])
actual_line = np.concatenate([[np.nan]*len(train_targets), y_true_trimmed])
forecast_line = np.concatenate([[np.nan]*len(train_targets), y_pred_trimmed])

# Plot
plt.figure(figsize=(18, 6))
plt.plot(full_timeline, train_line, label="Training Data", color="green")
plt.plot(full_timeline, actual_line, label="Actual Data", color="red")
plt.plot(full_timeline, forecast_line, label="Forecasted Data", color="blue", linestyle='--')

# Style
plt.title("Dengue Cases Forecast - City: SJ")
plt.xlabel("Time Step (Weeks)")
plt.ylabel("Total Cases")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

