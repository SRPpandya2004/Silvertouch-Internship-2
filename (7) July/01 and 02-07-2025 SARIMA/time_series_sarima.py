# -*- coding: utf-8 -*-
"""Time_series_Sarima.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TNBZYnHnpybb6FfYS9o_n8yok1GefB15

# **SARIMA Model**

# Step 1: SARIMA Model on time series
"""

# Cell 1: Load, split, and fit once

import pandas as pd
import pmdarima as pm

# 1) LOAD & PREPARE
df = (
    pd.read_csv('/content/sample_data/milk_production.csv',
                parse_dates=['Month'],
                index_col='Month')
      .asfreq('MS')
)
# 2) SPLIT INTO TRAIN/TEST
h_test   = 12
df_train = df.iloc[:-h_test]
df_test  = df.iloc[-h_test:]

# 3) FIT SEASONAL auto_arima on the training series
auto_model = pm.auto_arima(
    df_train['Production'],
    seasonal=True, m=12,
    stepwise=True, suppress_warnings=True
)

# show the chosen orders
print(auto_model.summary())

"""## Transform to stationary: differencing"""



pip install pmdarima

"""# Optional: Auto-fit the ARIMA model"""

pip install --upgrade "numpy<2"

# Cell 2: interactively choose years to forecast and plot

import matplotlib.pyplot as plt
from pandas.tseries.offsets import DateOffset
from ipywidgets import interact, IntSlider

def forecast_and_plot(years):
    # a) compute horizons
    h_future = years * 12
    h_total  = h_test + h_future

    # b) one-shot forecast (test+future)
    fc_all     = auto_model.predict(n_periods=h_total)
    fc_test    = fc_all[:h_test]
    fc_future  = fc_all[h_test:]

    # c) build timestamp indexes
    idx_test   = df_test.index
    last_train = df_train.index[-1]
    freq       = df.index.freq or pd.infer_freq(df.index) or 'MS'
    idx_future = pd.date_range(
        start=last_train + DateOffset(months=1),
        periods=h_future,
        freq=freq
    )

    # d) wrap into Series
    s_train     = df_train['Production']
    s_test      = df_test['Production']
    s_fc_test   = pd.Series(fc_test,   index=idx_test)
    s_fc_future = pd.Series(fc_future, index=idx_future)

    # e) plot
    fig, ax = plt.subplots(figsize=(12, 5))
    ax.plot(s_train,      color='blue',  linestyle='-',  label='Train')
    ax.plot(s_test,       color='green', linestyle='-',  label='Test Actual')
    ax.plot(s_fc_test,    color='red',   linestyle='--', label='Forecast on Test')
    ax.plot(s_fc_future,  color='red',   linestyle='--', linewidth=2,
            label=f'Forecast Next {years} yrs')

    # extend x‐axis
    ax.set_xlim(s_train.index[0], s_fc_future.index[-1])

    ax.set_title('Milk Production: Historical, Test & Future Forecast')
    ax.set_xlabel('Date')
    ax.set_ylabel('Production')
    ax.legend()
    ax.grid(True)
    plt.show()

# interactive slider: 1–10 years
max1=int(input("Enter Year limit : "))
interact(

    forecast_and_plot,
    years=IntSlider(min=1, max=max1, step=1, value=2, description='Years')
);

auto_sarima.summary()

# prompt: evaluate model predictions include mape,mae,rmse error

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np

def calculate_errors(y_true, y_pred):
  """
  Calculates MAPE, MAE, and RMSE errors.

  Args:
    y_true: The actual values.
    y_pred: The predicted values.

  Returns:
    A dictionary containing the MAPE, MAE, and RMSE values.
  """
  # Calculate MAE
  mae = mean_absolute_error(y_true, y_pred)

  # Calculate RMSE
  rmse = np.sqrt(mean_squared_error(y_true, y_pred))

  # Calculate MAPE (avoid division by zero)
  mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100 if np.all(y_true != 0) else float('inf')

  return {'MAE': mae, 'RMSE': rmse, 'MAPE': mape}

# After you generate the forecast on the test set (s_fc_test)
# You can calculate the errors by comparing it to the actual test data (s_test)

# Inside the forecast_and_plot function, after calculating s_fc_test
# You can add the following lines to calculate and print the errors:

# d) wrap into Series
s_train     = df_train['Production']
s_test      = df_test['Production']
s_fc_test   = pd.Series(fc_test,   index=idx_test)
s_fc_future = pd.Series(fc_future, index=idx_future)

# Calculate and print the errors on the test set
test_errors = calculate_errors(s_test, s_fc_test)
print("\nTest Set Evaluation Metrics:")
print(f"  MAE: {test_errors['MAE']:.2f}")
print(f"  RMSE: {test_errors['RMSE']:.2f}")
print(f"  MAPE: {test_errors['MAPE']:.2f}%")

# e) plot
fig, ax = plt.subplots(figsize=(12, 5))
ax.plot(s_train,      color='blue',  linestyle='-',  label='Train')
ax.plot(s_test,       color='green', linestyle='-',  label='Test Actual')
ax.plot(s_fc_test,    color='red',   linestyle='--', label='Forecast on Test')
ax.plot(s_fc_future,  color='red',   linestyle='--', linewidth=2,
        label=f'Forecast Next {years} yrs')

# extend x‐axis
ax.set_xlim(s_train.index[0], s_fc_future.index[-1])

ax.set_title('Milk Production: Historical, Test & Future Forecast')
ax.set_xlabel('Date')
ax.set_ylabel('Production')
ax.legend()
ax.grid(True)
plt.show()